import jk.log
import jk.sqlite
import jk.mysql
import jk.sql
import jk.env
import jk.time

class:

model Note
{
    id as string
    note as string
}
const NOTE = "note"
pvar db as MySQLDatabase

func forContext(ctx as LoggingContext) static as this
{
    var cstr = EnvironmentVariable.get("NOTE_DATABASE")
    Log.debug(ctx, "Opening database connection: '" .. cstr .."'")
    db = MySQLDatabase.forConnectionStringSync(ctx, cstr)
    if not db:
        Error.throw("failedToConnectToDatabase", cstr)
    var v = new this()
    v.setDb(db)
    return v
}

func updateTable(table as SQLTableInfo)
{
    if not table:
        Error.throw("nullTable", "updateTable")
    if not db:
        Error.throw("nullDb", "updateTable")
    if not db.ensureTableExistsSync(table):
        Error.throw("failedToUpdateTable", table.getName())
}

func updateTables
{
    var note = SQLTableInfo.forName(NOTE)
    note.addStringKeyColumn("id")
    note.addStringColumn("note")
    updateTable(note)
}


func getNote as DynamicMap
{
    var v = new vector<Note>
    var it = assert db.querySync(db.prepareQueryAllStatementSync(NOTE)):
        return null
    while it {
        var o = it.next()
        if not o:
            break
        var note = Note.forJsonObject(o)
        if not note:
            continue
        v += note
    }
    var data = new DynamicMap()
    data.setObject("records", v)
    return data
}

func close
{
    if db:
        db.closeSync()
    db = null
}
